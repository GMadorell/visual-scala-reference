<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Visual Scala Reference </title>
</head>
<body>
  <header>
    <h1>Visual Scala Reference </h1>
    <p>Available languages </p>
    <ul>
        <li><a href="index-en.html">English</a></li>
        <li><a href="index-es.html">Español</a></li>
    </ul>
  </header>
  <div>
    <aside>
      <ul>
          <li><a href="#aggregate" title="aggregate">aggregate</a></li>
          <li><a href="#collect" title="collect">collect</a></li>
          <li><a href="#collectFirst" title="collectFirst">collectFirst</a></li>
          <li><a href="#combinations" title="combinations">combinations</a></li>
          <li><a href="#contains" title="contains">contains</a></li>
          <li><a href="#containsSlice" title="containsSlice">containsSlice</a></li>
          <li><a href="#count" title="count">count</a></li>
          <li><a href="#diff" title="diff">diff</a></li>
          <li><a href="#distinct" title="distinct">distinct</a></li>
          <li><a href="#drop" title="drop">drop</a></li>
          <li><a href="#dropRight" title="dropRight">dropRight</a></li>
          <li><a href="#dropWhile" title="dropWhile">dropWhile</a></li>
          <li><a href="#endsWith" title="endsWith">endsWith</a></li>
          <li><a href="#exists" title="exists">exists</a></li>
          <li><a href="#filter" title="filter">filter</a></li>
          <li><a href="#filterNot" title="filterNot">filterNot</a></li>
          <li><a href="#find" title="find">find</a></li>
          <li><a href="#flatMap" title="flatMap">flatMap</a></li>
          <li><a href="#flatten" title="flatten">flatten</a></li>
          <li><a href="#fold" title="fold">fold</a></li>
          <li><a href="#foldLeft" title="foldLeft">foldLeft</a></li>
          <li><a href="#foldRight" title="foldRight">foldRight</a></li>
          <li><a href="#forall" title="forall">forall</a></li>
          <li><a href="#foreach" title="foreach">foreach</a></li>
          <li><a href="#groupBy" title="groupBy">groupBy</a></li>
          <li><a href="#grouped" title="grouped">grouped</a></li>
          <li><a href="#head" title="head">head</a></li>
          <li><a href="#headOption" title="headOption">headOption</a></li>
          <li><a href="#indexOf" title="indexOf">indexOf</a></li>
          <li><a href="#indexOfSlice" title="indexOfSlice">indexOfSlice</a></li>
          <li><a href="#indexWhere" title="indexWhere">indexWhere</a></li>
          <li><a href="#indices" title="indices">indices</a></li>
          <li><a href="#init" title="init">init</a></li>
          <li><a href="#inits" title="inits">inits</a></li>
          <li><a href="#intersect" title="intersect">intersect</a></li>
          <li><a href="#isEmpty" title="isEmpty">isEmpty</a></li>
          <li><a href="#last" title="last">last</a></li>
          <li><a href="#lastIndexOf" title="lastIndexOf">lastIndexOf</a></li>
          <li><a href="#lastIndexOfSlice" title="lastIndexOfSlice">lastIndexOfSlice</a></li>
          <li><a href="#lastIndexWhere" title="lastIndexWhere">lastIndexWhere</a></li>
          <li><a href="#lastOption" title="lastOption">lastOption</a></li>
          <li><a href="#length" title="length">length</a></li>
          <li><a href="#map" title="map">map</a></li>
          <li><a href="#mapConserve" title="mapConserve">mapConserve</a></li>
          <li><a href="#max" title="max">max</a></li>
          <li><a href="#maxBy" title="maxBy">maxBy</a></li>
          <li><a href="#min" title="min">min</a></li>
          <li><a href="#minBy" title="minBy">minBy</a></li>
          <li><a href="#mkString" title="mkString">mkString</a></li>
          <li><a href="#nonEmpty" title="nonEmpty">nonEmpty</a></li>
          <li><a href="#padTo" title="padTo">padTo</a></li>
          <li><a href="#partition" title="partition">partition</a></li>
          <li><a href="#patch" title="patch">patch</a></li>
          <li><a href="#permutations" title="permutations">permutations</a></li>
          <li><a href="#prefixLength" title="prefixLength">prefixLength</a></li>
          <li><a href="#reduce" title="reduce">reduce</a></li>
          <li><a href="#reduceLeft" title="reduceLeft">reduceLeft</a></li>
          <li><a href="#reduceLeftOption" title="reduceLeftOption">reduceLeftOption</a></li>
          <li><a href="#reduceOption" title="reduceOption">reduceOption</a></li>
          <li><a href="#reduceRight" title="reduceRight">reduceRight</a></li>
          <li><a href="#reduceRightOption" title="reduceRightOption">reduceRightOption</a></li>
          <li><a href="#reverse" title="reverse">reverse</a></li>
          <li><a href="#reverseMap" title="reverseMap">reverseMap</a></li>
          <li><a href="#sameElements" title="sameElements">sameElements</a></li>
          <li><a href="#scan" title="scan">scan</a></li>
          <li><a href="#scanLeft" title="scanLeft">scanLeft</a></li>
          <li><a href="#scanRight" title="scanRight">scanRight</a></li>
          <li><a href="#segmentLength" title="segmentLength">segmentLength</a></li>
          <li><a href="#size" title="size">size</a></li>
          <li><a href="#slice" title="slice">slice</a></li>
          <li><a href="#sliding" title="sliding">sliding</a></li>
          <li><a href="#sortBy" title="sortBy">sortBy</a></li>
          <li><a href="#sortWith" title="sortWith">sortWith</a></li>
          <li><a href="#sorted" title="sorted">sorted</a></li>
          <li><a href="#span" title="span">span</a></li>
          <li><a href="#splitAt" title="splitAt">splitAt</a></li>
          <li><a href="#startsWith" title="startsWith">startsWith</a></li>
          <li><a href="#sum" title="sum">sum</a></li>
          <li><a href="#tail" title="tail">tail</a></li>
          <li><a href="#tails" title="tails">tails</a></li>
          <li><a href="#take" title="take">take</a></li>
          <li><a href="#takeRight" title="takeRight">takeRight</a></li>
          <li><a href="#takeWhile" title="takeWhile">takeWhile</a></li>
          <li><a href="#union" title="union">union</a></li>
          <li><a href="#unzip" title="unzip">unzip</a></li>
          <li><a href="#unzip3" title="unzip3">unzip3</a></li>
          <li><a href="#updated" title="updated">updated</a></li>
          <li><a href="#zip" title="zip">zip</a></li>
          <li><a href="#zipAll" title="zipAll">zipAll</a></li>
          <li><a href="#zipWithIndex" title="zipWithIndex">zipWithIndex</a></li>
      </ul>
    </aside>
    <section>
        <article id="aggregate">
          <h2>aggregate</h2>
          <p>   </p>
          <p><code>aggregate[B](z: ⇒ B)(seqop: (B, A) ⇒ B, combop: (B, B) ⇒ B): B</code></p>
          <figure>
            <img src="images/aggregate.svg" alt="aggregate" />
          </figure>
        </article>
        <article id="collect">
          <h2>collect</h2>
          <p>Builds a new collection by applying a partial function to all elements of this collection on which the function is defined. </p>
          <p><code>collect[B](pf: PartialFunction[A, B]): Collection[B]</code></p>
          <figure>
            <img src="images/collect.svg" alt="collect" />
          </figure>
        </article>
        <article id="collectFirst">
          <h2>collectFirst</h2>
          <p>Finds the first element of the collection for which the given partial function is defined, and applies the partial function to it. </p>
          <p><code>collectFirst[B](pf: PartialFunction[A, B]): Option[B]</code></p>
          <figure>
            <img src="images/collectFirst.svg" alt="collectFirst" />
          </figure>
        </article>
        <article id="combinations">
          <h2>combinations</h2>
          <p>Iterates over combinations. </p>
          <p><code>combinations(n: Int): Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/combinations.svg" alt="combinations" />
          </figure>
        </article>
        <article id="contains">
          <h2>contains</h2>
          <p>Tests whether this collection contains a given value as an element. </p>
          <p><code>contains[A1 &gt;: A](elem: A1): Boolean</code></p>
          <figure>
            <img src="images/contains.svg" alt="contains" />
          </figure>
        </article>
        <article id="containsSlice">
          <h2>containsSlice</h2>
          <p>Tests whether this collection contains a given sequence as a slice. </p>
          <p><code>containsSlice[B](that: GenSeq[B]): Boolean</code></p>
          <figure>
            <img src="images/containsSlice.svg" alt="containsSlice" />
          </figure>
        </article>
        <article id="count">
          <h2>count</h2>
          <p>Counts the number of elements in the collection which satisfy a predicate. </p>
          <p><code>count(p: (A) ⇒ Boolean): Int</code></p>
          <figure>
            <img src="images/count.svg" alt="count" />
          </figure>
        </article>
        <article id="diff">
          <h2>diff</h2>
          <p>Computes the multiset difference between this and another collection. </p>
          <p><code>diff(that: Seq[A]): Collection[A]</code></p>
          <figure>
            <img src="images/diff.svg" alt="diff" />
          </figure>
        </article>
        <article id="distinct">
          <h2>distinct</h2>
          <p>Builds a new collection from this one without any duplicate elements. </p>
          <p><code>distinct: Collection[A]</code></p>
          <figure>
            <img src="images/distinct.svg" alt="distinct" />
          </figure>
        </article>
        <article id="drop">
          <h2>drop</h2>
          <p>Selects all elements except the first <var>n</var> ones. </p>
          <p><code>drop(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/drop.svg" alt="drop" />
          </figure>
        </article>
        <article id="dropRight">
          <h2>dropRight</h2>
          <p>Select all elements except last <var>n</var> ones. </p>
          <p><code>dropRight(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/dropRight.svg" alt="dropRight" />
          </figure>
        </article>
        <article id="dropWhile">
          <h2>dropWhile</h2>
          <p>Drops longest prefix of elements that satisfy a predicate. </p>
          <p><code>dropWhile(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/dropWhile.svg" alt="dropWhile" />
          </figure>
        </article>
        <article id="endsWith">
          <h2>endsWith</h2>
          <p>Tests whether this collection ends with the given sequence. </p>
          <p><code>endsWith[B](that: GenSeq[B]): Boolean</code></p>
          <figure>
            <img src="images/endsWith.svg" alt="endsWith" />
          </figure>
        </article>
        <article id="exists">
          <h2>exists</h2>
          <p>Tests whether a predicate holds for at least one element of this collection. </p>
          <p><code>exists(p: (A) ⇒ Boolean): Boolean</code></p>
          <figure>
            <img src="images/exists.svg" alt="exists" />
          </figure>
        </article>
        <article id="filter">
          <h2>filter</h2>
          <p>Selects all elements of this traversable collection which satisfy a predicate. </p>
          <p><code>filter(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/filter.svg" alt="filter" />
          </figure>
        </article>
        <article id="filterNot">
          <h2>filterNot</h2>
          <p>Selects all elements of this collection which do not satisfy a predicate. </p>
          <p><code>filterNot(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/filterNot.svg" alt="filterNot" />
          </figure>
        </article>
        <article id="find">
          <h2>find</h2>
          <p>Finds the first element of the collection satisfying a predicate, if any. </p>
          <p><code>find(p: (A) ⇒ Boolean): Option[A]</code></p>
          <figure>
            <img src="images/find.svg" alt="find" />
          </figure>
        </article>
        <article id="flatMap">
          <h2>flatMap</h2>
          <p>Builds a new collection by applying a function to all elements of this collection and using the elements of the resulting collections. </p>
          <p><code>flatMap[B](f: (A) ⇒ Collection[B]): Collection[B]</code></p>
          <figure>
            <img src="images/flatMap.svg" alt="flatMap" />
          </figure>
        </article>
        <article id="flatten">
          <h2>flatten</h2>
          <p>Converts this collection of collections into a collection formed by the elements of the inner collections. </p>
          <p><code>flatten[B]: Collection[B]</code></p>
          <figure>
            <img src="images/flatten.svg" alt="flatten" />
          </figure>
        </article>
        <article id="fold">
          <h2>fold</h2>
          <p>Folds the elements of this collection using the specified associative binary operator. </p>
          <p><code>fold[A1 &gt;: A](z: A1)(op: (A1, A1) ⇒ A1): A1</code></p>
          <figure>
            <img src="images/fold.svg" alt="fold" />
          </figure>
        </article>
        <article id="foldLeft">
          <h2>foldLeft</h2>
          <p>Applies a binary operator to a start value and all elements of this collection, going left to right. </p>
          <p><code>foldLeft[B](z: B)(op: (B, A) ⇒ B): B</code></p>
          <figure>
            <img src="images/foldLeft.svg" alt="foldLeft" />
          </figure>
        </article>
        <article id="foldRight">
          <h2>foldRight</h2>
          <p>Applies a binary operator to a start value and all elements of this collection, going right to left. </p>
          <p><code>foldLeft[B](z: B)(op: (A, B) ⇒ B): B</code></p>
          <figure>
            <img src="images/foldRight.svg" alt="foldRight" />
          </figure>
        </article>
        <article id="forall">
          <h2>forall</h2>
          <p>Tests whether a predicate holds for all elements of this collection. </p>
          <p><code>forall(p: (A) ⇒ Boolean): Boolean</code></p>
          <figure>
            <img src="images/forall.svg" alt="forall" />
          </figure>
        </article>
        <article id="foreach">
          <h2>foreach</h2>
          <p>Applies a function <var>f</var> to all elements of this collection. </p>
          <p><code>foreach(f: (A) ⇒ Unit): Unit</code></p>
          <figure>
            <img src="images/foreach.svg" alt="foreach" />
          </figure>
        </article>
        <article id="groupBy">
          <h2>groupBy</h2>
          <p>Partitions this collection into a map of collections according to some discriminator function. </p>
          <p><code>groupBy[K](f: (A) ⇒ K): Map[K, Collection[A]]</code></p>
          <figure>
            <img src="images/groupBy.svg" alt="groupBy" />
          </figure>
        </article>
        <article id="grouped">
          <h2>grouped</h2>
          <p>Partitions elements in fixed size iterable collections. </p>
          <p><code>grouped(size: Int): Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/grouped.svg" alt="grouped" />
          </figure>
        </article>
        <article id="head">
          <h2>head</h2>
          <p>Selects the first element of this collection. </p>
          <p><code>head: A</code></p>
          <figure>
            <img src="images/head.svg" alt="head" />
          </figure>
        </article>
        <article id="headOption">
          <h2>headOption</h2>
          <p>Optionally selects the first element. </p>
          <p><code>headOption: Option[A]</code></p>
          <figure>
            <img src="images/headOption.svg" alt="headOption" />
          </figure>
        </article>
        <article id="indexOf">
          <h2>indexOf</h2>
          <p>Finds index of first occurrence of some value in this collection after or at some start index. </p>
          <p><code>indexOf(elem: A, from: Int): Int</code></p>
          <figure>
            <img src="images/indexOf.svg" alt="indexOf" />
          </figure>
        </article>
        <article id="indexOfSlice">
          <h2>indexOfSlice</h2>
          <p>Finds first index after or at a start index where this collection contains a given sequence as a slice. </p>
          <p><code>indexOfSlice[B &gt;: A](that: GenSeq[B], from: Int): Int</code></p>
          <figure>
            <img src="images/indexOfSlice.svg" alt="indexOfSlice" />
          </figure>
        </article>
        <article id="indexWhere">
          <h2>indexWhere</h2>
          <p>Finds index of the first element satisfying some predicate after or at some start index. </p>
          <p><code>indexWhere(p: (A) ⇒ Boolean, from: Int): Int</code></p>
          <figure>
            <img src="images/indexWhere.svg" alt="indexWhere" />
          </figure>
        </article>
        <article id="indices">
          <h2>indices</h2>
          <p>Produces the range of all indices of this collection. </p>
          <p><code>indices: Range</code></p>
          <figure>
            <img src="images/indices.svg" alt="indices" />
          </figure>
        </article>
        <article id="init">
          <h2>init</h2>
          <p>Select all elements except the last. </p>
          <p><code>init: Collection[A]</code></p>
          <figure>
            <img src="images/init.svg" alt="init" />
          </figure>
        </article>
        <article id="inits">
          <h2>inits</h2>
          <p>Iterates over the inits of this collection. </p>
          <p><code>inits: Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/inits.svg" alt="inits" />
          </figure>
        </article>
        <article id="intersect">
          <h2>intersect</h2>
          <p>Computes the multiset intersection between this collection and another sequence. </p>
          <p><code>intersect(that: Seq[A]): Collection[A]</code></p>
          <figure>
            <img src="images/intersect.svg" alt="intersect" />
          </figure>
        </article>
        <article id="isEmpty">
          <h2>isEmpty</h2>
          <p>Tests whether this collection is empty. </p>
          <p><code>isEmpty: Boolean</code></p>
          <figure>
            <img src="images/isEmpty.svg" alt="isEmpty" />
          </figure>
        </article>
        <article id="last">
          <h2>last</h2>
          <p>Selects the last element. </p>
          <p><code>last: A</code></p>
          <figure>
            <img src="images/last.svg" alt="last" />
          </figure>
        </article>
        <article id="lastIndexOf">
          <h2>lastIndexOf</h2>
          <p>Finds index of last occurrence of some value in this colección before or at a given end index. </p>
          <p><code>lastIndexOf(elem: A, end: Int): Int</code></p>
          <figure>
            <img src="images/lastIndexOf.svg" alt="lastIndexOf" />
          </figure>
        </article>
        <article id="lastIndexOfSlice">
          <h2>lastIndexOfSlice</h2>
          <p>Finds last index before or at a given end index where this collection contains a given sequence as a slice. </p>
          <p><code>lastIndexOfSlice[B &gt;: A](that: GenSeq[B], end: Int): Int</code></p>
          <figure>
            <img src="images/lastIndexOfSlice.svg" alt="lastIndexOfSlice" />
          </figure>
        </article>
        <article id="lastIndexWhere">
          <h2>lastIndexWhere</h2>
          <p>Finds index of last element satisfying some predicate before or at a given end index. </p>
          <p><code>lastIndexWhere(p: (A) ⇒ Boolean, end: Int): Int</code></p>
          <figure>
            <img src="images/lastIndexWhere.svg" alt="lastIndexWhere" />
          </figure>
        </article>
        <article id="lastOption">
          <h2>lastOption</h2>
          <p>Optionally selects the last element. </p>
          <p><code>lastOption: Option[A]</code></p>
          <figure>
            <img src="images/lastOption.svg" alt="lastOption" />
          </figure>
        </article>
        <article id="length">
          <h2>length</h2>
          <p>The length of the collection. </p>
          <p><code>length: Int</code></p>
          <figure>
            <img src="images/length.svg" alt="length" />
          </figure>
        </article>
        <article id="map">
          <h2>map</h2>
          <p>Builds a new collection by applying a function to all elements of this collection. </p>
          <p><code>map[B](f: (A) ⇒ B): Collection[B]</code></p>
          <figure>
            <img src="images/map.svg" alt="map" />
          </figure>
        </article>
        <article id="mapConserve">
          <h2>mapConserve</h2>
          <p>Builds a new collection by applying a function to all elements of this collection. Like <code>xs map f</code>, but returns <var>xs</var> unchanged if function <var>f</var> maps all elements to themselves (as determined by <var>eq</var>) </p>
          <p><code>mapConserve(f: (A) ⇒ A): Collection[A]</code></p>
          <figure>
            <img src="images/mapConserve.svg" alt="mapConserve" />
          </figure>
        </article>
        <article id="max">
          <h2>max</h2>
          <p>Finds the largest element. </p>
          <p><code>max: A</code></p>
          <figure>
            <img src="images/max.svg" alt="max" />
          </figure>
        </article>
        <article id="maxBy">
          <h2>maxBy</h2>
          <p>Finds the first element which yields the largest value measured by function <var>f</var>. </p>
          <p><code>maxBy[B](f: (A) ⇒ B): A</code></p>
          <figure>
            <img src="images/maxBy.svg" alt="maxBy" />
          </figure>
        </article>
        <article id="min">
          <h2>min</h2>
          <p>Finds the smallest element. </p>
          <p><code>min: A</code></p>
          <figure>
            <img src="images/min.svg" alt="min" />
          </figure>
        </article>
        <article id="minBy">
          <h2>minBy</h2>
          <p>Finds the first element which yields the smallest value measured by function <var>f</var>. </p>
          <p><code>minBy[B](f: (A) ⇒ B): A</code></p>
          <figure>
            <img src="images/minBy.svg" alt="minBy" />
          </figure>
        </article>
        <article id="mkString">
          <h2>mkString</h2>
          <p>Displays all elements of this collection in a string. </p>
          <p><code>mkString(start: String, sep: String, end: String): String</code></p>
          <figure>
            <img src="images/mkString.svg" alt="mkString" />
          </figure>
        </article>
        <article id="nonEmpty">
          <h2>nonEmpty</h2>
          <p>Tests whether the collection is not empty. </p>
          <p><code>nonEmpty: Boolean</code></p>
          <figure>
            <img src="images/nonEmpty.svg" alt="nonEmpty" />
          </figure>
        </article>
        <article id="padTo">
          <h2>padTo</h2>
          <p>A copy of this collection with an element value appended until a given target length is reached. </p>
          <p><code>padTo(len: Int, elem: A): Collection[A]</code></p>
          <figure>
            <img src="images/padTo.svg" alt="padTo" />
          </figure>
        </article>
        <article id="partition">
          <h2>partition</h2>
          <p>Partitions this collection in two collections according to a predicate. </p>
          <p><code>partition(p: (A) ⇒ Boolean): (Collection[A], Collection[A])</code></p>
          <figure>
            <img src="images/partition.svg" alt="partition" />
          </figure>
        </article>
        <article id="patch">
          <h2>patch</h2>
          <p>Produces a new collection where a slice of elements in this collection is replaced by another sequence. </p>
          <p><code>patch(from: Int, that: GenSeq[A], replaced: Int): Collection[A]</code></p>
          <figure>
            <img src="images/patch.svg" alt="patch" />
          </figure>
        </article>
        <article id="permutations">
          <h2>permutations</h2>
          <p>Iterates over distinct permutations. </p>
          <p><code>permutations: Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/permutations.svg" alt="permutations" />
          </figure>
        </article>
        <article id="prefixLength">
          <h2>prefixLength</h2>
          <p>Returns the length of the longest prefix whose elements all satisfy some predicate. </p>
          <p><code>prefixLength(p: (A) ⇒ Boolean): Int</code></p>
          <figure>
            <img src="images/prefixLength.svg" alt="prefixLength" />
          </figure>
        </article>
        <article id="reduce">
          <h2>reduce</h2>
          <p>Reduces the elements of this collection using the specified associative binary operator. </p>
          <p><code>reduce[A1 &gt;: A](op: (A1, A1) ⇒ A1): A1</code></p>
          <figure>
            <img src="images/reduce.svg" alt="reduce" />
          </figure>
        </article>
        <article id="reduceLeft">
          <h2>reduceLeft</h2>
          <p>Applies a binary operator to all elements of this collection, going left to right. </p>
          <p><code>reduceLeft[B &gt;: A](op: (B, A) ⇒ B): B</code></p>
          <figure>
            <img src="images/reduceLeft.svg" alt="reduceLeft" />
          </figure>
        </article>
        <article id="reduceLeftOption">
          <h2>reduceLeftOption</h2>
          <p>Optionally applies a binary operator to all elements of this collection, going left to right. </p>
          <p><code>reduceLeftOption[B &gt;: A](op: (B, A) ⇒ B): Option[B]</code></p>
          <figure>
            <img src="images/reduceLeftOption.svg" alt="reduceLeftOption" />
          </figure>
        </article>
        <article id="reduceOption">
          <h2>reduceOption</h2>
          <p>Reduces the elements of this collection, if any, using the specified associative binary operator. </p>
          <p><code>reduceOption[A1 &gt;: A](op: (A1, A1) ⇒ A1): Option[A1]</code></p>
          <figure>
            <img src="images/reduceOption.svg" alt="reduceOption" />
          </figure>
        </article>
        <article id="reduceRight">
          <h2>reduceRight</h2>
          <p>Applies a binary operator to all elements of this collection, going right to left. </p>
          <p><code>reduceRight[B &gt;: A](op: (A, B) ⇒ B): B</code></p>
          <figure>
            <img src="images/reduceRight.svg" alt="reduceRight" />
          </figure>
        </article>
        <article id="reduceRightOption">
          <h2>reduceRightOption</h2>
          <p>Optionally, applies a binary operator to all elements of this collection, going right to left. </p>
          <p><code>reduceRightOption[B &gt;: A](op: (A, B) ⇒ B): Option[B]</code></p>
          <figure>
            <img src="images/reduceRightOption.svg" alt="reduceRightOption" />
          </figure>
        </article>
        <article id="reverse">
          <h2>reverse</h2>
          <p>Returns new collection with elements in reversed order. </p>
          <p><code>reverse: Collection[A]</code></p>
          <figure>
            <img src="images/reverse.svg" alt="reverse" />
          </figure>
        </article>
        <article id="reverseMap">
          <h2>reverseMap</h2>
          <p>Builds a new collection by applying a function to all elements of this collection and collecting the results in reversed order. </p>
          <p><code>reverseMap(f: (A) ⇒ B): Collection[A]</code></p>
          <figure>
            <img src="images/reverseMap.svg" alt="reverseMap" />
          </figure>
        </article>
        <article id="sameElements">
          <h2>sameElements</h2>
          <p>Checks if the other collection contains the same elements in the same order as this one. </p>
          <p><code>sameElements(that: GenIterable[A]): Boolean</code></p>
          <figure>
            <img src="images/sameElements.svg" alt="sameElements" />
          </figure>
        </article>
        <article id="scan">
          <h2>scan</h2>
          <p>Computes a prefix scan of the elements of the collection. </p>
          <p><code>scan[B &gt;: A](z: B)(op: (B, B) ⇒ B)</code></p>
          <figure>
            <img src="images/scan.svg" alt="scan" />
          </figure>
        </article>
        <article id="scanLeft">
          <h2>scanLeft</h2>
          <p>Produces a collection containing cumulative results of applying the operator going left to right. </p>
          <p><code>scanLeft[B](z: B)(op: (B, A) ⇒ B)</code></p>
          <figure>
            <img src="images/scanLeft.svg" alt="scanLeft" />
          </figure>
        </article>
        <article id="scanRight">
          <h2>scanRight</h2>
          <p>Produces a collection containing cumulative results of applying the operator going right to left. </p>
          <p><code>scanRight[B](z: B)(op: (A, B) ⇒ B)</code></p>
          <figure>
            <img src="images/scanRight.svg" alt="scanRight" />
          </figure>
        </article>
        <article id="segmentLength">
          <h2>segmentLength</h2>
          <p>Computes length of longest segment whose elements all satisfy some predicate. </p>
          <p><code>segmentLength(p: (A) ⇒ Boolean, from: Int): Int</code></p>
          <figure>
            <img src="images/segmentLength.svg" alt="segmentLength" />
          </figure>
        </article>
        <article id="size">
          <h2>size</h2>
          <p>The size of this collection. </p>
          <p><code>size: Int</code></p>
          <figure>
            <img src="images/size.svg" alt="size" />
          </figure>
        </article>
        <article id="slice">
          <h2>slice</h2>
          <p>   </p>
          <p><code>slice(from: Int, until: Int): Collection[A]</code></p>
          <figure>
            <img src="images/slice.svg" alt="slice" />
          </figure>
        </article>
        <article id="sliding">
          <h2>sliding</h2>
          <p>Groups elements in fixed size blocks by passing a "sliding window" over them. </p>
          <p><code>sliding(size: Int, step: Int): Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/sliding.svg" alt="sliding" />
          </figure>
        </article>
        <article id="sortBy">
          <h2>sortBy</h2>
          <p>Sorts this collection according to the Ordering which results from transforming an implicitly given Ordering with a transformation function. </p>
          <p><code>sortBy[B](f: (A) ⇒ B)(implicit ord: math.Ordering[B]): Collection[A]</code></p>
          <figure>
            <img src="images/sortBy.svg" alt="sortBy" />
          </figure>
        </article>
        <article id="sortWith">
          <h2>sortWith</h2>
          <p>Sorts this collection according to a comparison function. </p>
          <p><code>sortWith(lt: (A, A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/sortWith.svg" alt="sortWith" />
          </figure>
        </article>
        <article id="sorted">
          <h2>sorted</h2>
          <p>Sorts this collection according to an Ordering. </p>
          <p><code>sorted[B &gt;: A]</code></p>
          <figure>
            <img src="images/sorted.svg" alt="sorted" />
          </figure>
        </article>
        <article id="span">
          <h2>span</h2>
          <p>Splits this collection into a prefix/suffix pair according to a predicate. </p>
          <p><code>span(p: (A) ⇒ Boolean): (Collection[A], Collection[A])</code></p>
          <figure>
            <img src="images/span.svg" alt="span" />
          </figure>
        </article>
        <article id="splitAt">
          <h2>splitAt</h2>
          <p>Splits this collection into two at a given position. </p>
          <p><code>splitAt(n: Int): (Collection[A], Collection[A])</code></p>
          <figure>
            <img src="images/splitAt.svg" alt="splitAt" />
          </figure>
        </article>
        <article id="startsWith">
          <h2>startsWith</h2>
          <p>Tests whether this collection contains the given sequence at a given index. </p>
          <p><code>startsWith[B](that: GenSeq[B], offset: Int): Boolean</code></p>
          <figure>
            <img src="images/startsWith.svg" alt="startsWith" />
          </figure>
        </article>
        <article id="sum">
          <h2>sum</h2>
          <p>Sums up the elements of this collection. </p>
          <p><code>sum: A</code></p>
          <figure>
            <img src="images/sum.svg" alt="sum" />
          </figure>
        </article>
        <article id="tail">
          <h2>tail</h2>
          <p>Selects all elements except the first. </p>
          <p><code>tail: Collection[A]</code></p>
          <figure>
            <img src="images/tail.svg" alt="tail" />
          </figure>
        </article>
        <article id="tails">
          <h2>tails</h2>
          <p>Iterates over the tails of this collection. </p>
          <p><code>tails: Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/tails.svg" alt="tails" />
          </figure>
        </article>
        <article id="take">
          <h2>take</h2>
          <p>Selects first <var>n</var> elements. </p>
          <p><code>take(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/take.svg" alt="take" />
          </figure>
        </article>
        <article id="takeRight">
          <h2>takeRight</h2>
          <p>Selects last <var>n</var> elements. </p>
          <p><code>takeRight(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/takeRight.svg" alt="takeRight" />
          </figure>
        </article>
        <article id="takeWhile">
          <h2>takeWhile</h2>
          <p>Takes longest prefix of elements that satisfy a predicate. </p>
          <p><code>takeWhile(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/takeWhile.svg" alt="takeWhile" />
          </figure>
        </article>
        <article id="union">
          <h2>union</h2>
          <p>Produces a new collection which contains all elements of this one and also all elements of a given sequence. </p>
          <p><code>union(that: Seq[A]): Collection[A]</code></p>
          <figure>
            <img src="images/union.svg" alt="union" />
          </figure>
        </article>
        <article id="unzip">
          <h2>unzip</h2>
          <p>Converts this collection of pairs into two collections of the first and second half of each pair. </p>
          <p><code>unzip[A1, A2](implicit asPair: (A) ⇒ (A1, A2)): (Collection[A1], Collection[A2])</code></p>
          <figure>
            <img src="images/unzip.svg" alt="unzip" />
          </figure>
        </article>
        <article id="unzip3">
          <h2>unzip3</h2>
          <p>Converts this collection of triples into three collections of the first, second, and third element of each triple. </p>
          <p><code>unzip3[A1, A2, A3](implicit asTriple: (A) ⇒ (A1, A2, A3)): (Collection[A1], Collection[A2], Collection[A3])</code></p>
          <figure>
            <img src="images/unzip3.svg" alt="unzip3" />
          </figure>
        </article>
        <article id="updated">
          <h2>updated</h2>
          <p>A copy of this collection with one single replaced element. </p>
          <p><code>updated(index: Int, elem: A): Collection[A]</code></p>
          <figure>
            <img src="images/updated.svg" alt="updated" />
          </figure>
        </article>
        <article id="zip">
          <h2>zip</h2>
          <p>Returns a collection formed from this and another one by combining corresponding elements in pairs. </p>
          <p><code>zip[B](that: GenIterable[B]): Collection[A, B]</code></p>
          <figure>
            <img src="images/zip.svg" alt="zip" />
          </figure>
        </article>
        <article id="zipAll">
          <h2>zipAll</h2>
          <p>Returns a collection formed from this and another one by combining corresponding elements in pairs. If one of the two collections is shorter than the other, placeholder elements are used to extend the shorter collection to the length of the longer. </p>
          <p><code>zipAll[B](that: Iterable[B], thisElem: A, thatElem: B): Collection[(A, B)]</code></p>
          <figure>
            <img src="images/zipAll.svg" alt="zipAll" />
          </figure>
        </article>
        <article id="zipWithIndex">
          <h2>zipWithIndex</h2>
          <p>Zips this collection with its indices. </p>
          <p><code>zipWithIndex: Collection[A, Int]</code></p>
          <figure>
            <img src="images/zipWithIndex.svg" alt="zipWithIndex" />
          </figure>
        </article>
    </sectio>
  </div>
</body>
</html>
