<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Referencia visual de Scala </title>
</head>
<body>
  <header>
    <h1>Referencia visual de Scala </h1>
    <p>Idiomas disponibles </p>
    <ul>
        <li><a href="index-en.html">English</a></li>
        <li><a href="index-es.html">Español</a></li>
    </ul>
  </header>
  <div>
    <aside>
      <ul>
          <li><a href="#aggregate" title="aggregate">aggregate</a></li>
          <li><a href="#collect" title="collect">collect</a></li>
          <li><a href="#collectFirst" title="collectFirst">collectFirst</a></li>
          <li><a href="#combinations" title="combinations">combinations</a></li>
          <li><a href="#contains" title="contains">contains</a></li>
          <li><a href="#containsSlice" title="containsSlice">containsSlice</a></li>
          <li><a href="#count" title="count">count</a></li>
          <li><a href="#diff" title="diff">diff</a></li>
          <li><a href="#distinct" title="distinct">distinct</a></li>
          <li><a href="#drop" title="drop">drop</a></li>
          <li><a href="#dropRight" title="dropRight">dropRight</a></li>
          <li><a href="#dropWhile" title="dropWhile">dropWhile</a></li>
          <li><a href="#endsWith" title="endsWith">endsWith</a></li>
          <li><a href="#exists" title="exists">exists</a></li>
          <li><a href="#filter" title="filter">filter</a></li>
          <li><a href="#filterNot" title="filterNot">filterNot</a></li>
          <li><a href="#find" title="find">find</a></li>
          <li><a href="#flatMap" title="flatMap">flatMap</a></li>
          <li><a href="#flatten" title="flatten">flatten</a></li>
          <li><a href="#fold" title="fold">fold</a></li>
          <li><a href="#foldLeft" title="foldLeft">foldLeft</a></li>
          <li><a href="#foldRight" title="foldRight">foldRight</a></li>
          <li><a href="#forall" title="forall">forall</a></li>
          <li><a href="#foreach" title="foreach">foreach</a></li>
          <li><a href="#groupBy" title="groupBy">groupBy</a></li>
          <li><a href="#grouped" title="grouped">grouped</a></li>
          <li><a href="#head" title="head">head</a></li>
          <li><a href="#headOption" title="headOption">headOption</a></li>
          <li><a href="#indexOf" title="indexOf">indexOf</a></li>
          <li><a href="#indexOfSlice" title="indexOfSlice">indexOfSlice</a></li>
          <li><a href="#indexWhere" title="indexWhere">indexWhere</a></li>
          <li><a href="#indices" title="indices">indices</a></li>
          <li><a href="#init" title="init">init</a></li>
          <li><a href="#inits" title="inits">inits</a></li>
          <li><a href="#intersect" title="intersect">intersect</a></li>
          <li><a href="#isEmpty" title="isEmpty">isEmpty</a></li>
          <li><a href="#last" title="last">last</a></li>
          <li><a href="#lastIndexOf" title="lastIndexOf">lastIndexOf</a></li>
          <li><a href="#lastIndexOfSlice" title="lastIndexOfSlice">lastIndexOfSlice</a></li>
          <li><a href="#lastIndexWhere" title="lastIndexWhere">lastIndexWhere</a></li>
          <li><a href="#lastOption" title="lastOption">lastOption</a></li>
          <li><a href="#length" title="length">length</a></li>
          <li><a href="#map" title="map">map</a></li>
          <li><a href="#mapConserve" title="mapConserve">mapConserve</a></li>
          <li><a href="#max" title="max">max</a></li>
          <li><a href="#maxBy" title="maxBy">maxBy</a></li>
          <li><a href="#min" title="min">min</a></li>
          <li><a href="#minBy" title="minBy">minBy</a></li>
          <li><a href="#mkString" title="mkString">mkString</a></li>
          <li><a href="#nonEmpty" title="nonEmpty">nonEmpty</a></li>
          <li><a href="#padTo" title="padTo">padTo</a></li>
          <li><a href="#partition" title="partition">partition</a></li>
          <li><a href="#patch" title="patch">patch</a></li>
          <li><a href="#permutations" title="permutations">permutations</a></li>
          <li><a href="#prefixLength" title="prefixLength">prefixLength</a></li>
          <li><a href="#product" title="product">product</a></li>
          <li><a href="#reduce" title="reduce">reduce</a></li>
          <li><a href="#reduceLeft" title="reduceLeft">reduceLeft</a></li>
          <li><a href="#reduceLeftOption" title="reduceLeftOption">reduceLeftOption</a></li>
          <li><a href="#reduceOption" title="reduceOption">reduceOption</a></li>
          <li><a href="#reduceRight" title="reduceRight">reduceRight</a></li>
          <li><a href="#reduceRightOption" title="reduceRightOption">reduceRightOption</a></li>
          <li><a href="#reverse" title="reverse">reverse</a></li>
          <li><a href="#reverseMap" title="reverseMap">reverseMap</a></li>
          <li><a href="#sameElements" title="sameElements">sameElements</a></li>
          <li><a href="#scan" title="scan">scan</a></li>
          <li><a href="#scanLeft" title="scanLeft">scanLeft</a></li>
          <li><a href="#scanRight" title="scanRight">scanRight</a></li>
          <li><a href="#segmentLength" title="segmentLength">segmentLength</a></li>
          <li><a href="#size" title="size">size</a></li>
          <li><a href="#slice" title="slice">slice</a></li>
          <li><a href="#sliding" title="sliding">sliding</a></li>
          <li><a href="#sortBy" title="sortBy">sortBy</a></li>
          <li><a href="#sortWith" title="sortWith">sortWith</a></li>
          <li><a href="#sorted" title="sorted">sorted</a></li>
          <li><a href="#span" title="span">span</a></li>
          <li><a href="#splitAt" title="splitAt">splitAt</a></li>
          <li><a href="#startsWith" title="startsWith">startsWith</a></li>
          <li><a href="#sum" title="sum">sum</a></li>
          <li><a href="#tail" title="tail">tail</a></li>
          <li><a href="#tails" title="tails">tails</a></li>
          <li><a href="#take" title="take">take</a></li>
          <li><a href="#takeRight" title="takeRight">takeRight</a></li>
          <li><a href="#takeWhile" title="takeWhile">takeWhile</a></li>
          <li><a href="#union" title="union">union</a></li>
          <li><a href="#unzip" title="unzip">unzip</a></li>
          <li><a href="#unzip3" title="unzip3">unzip3</a></li>
          <li><a href="#updated" title="updated">updated</a></li>
          <li><a href="#zip" title="zip">zip</a></li>
          <li><a href="#zipAll" title="zipAll">zipAll</a></li>
          <li><a href="#zipWithIndex" title="zipWithIndex">zipWithIndex</a></li>
      </ul>
    </aside>
    <section>
        <article id="aggregate">
          <h2>aggregate</h2>
          <p>   </p>
          <p><code>aggregate[B](z: ⇒ B)(seqop: (B, A) ⇒ B, combop: (B, B) ⇒ B): B</code></p>
          <figure>
            <img src="images/aggregate.svg" alt="aggregate" />
          </figure>
        </article>
        <article id="collect">
          <h2>collect</h2>
          <p>Construye una nueva colección aplicando una función parcial a todos los elementos de esta colección para los que dicha función está definida. </p>
          <p><code>collect[B](pf: PartialFunction[A, B]): Collection[B]</code></p>
          <figure>
            <img src="images/collect.svg" alt="collect" />
          </figure>
        </article>
        <article id="collectFirst">
          <h2>collectFirst</h2>
          <p>Encuentra el primer elemento de la colección para el cual está definida una función parcial, aplicando después dicha función parcial. </p>
          <p><code>collectFirst[B](pf: PartialFunction[A, B]): Option[B]</code></p>
          <figure>
            <img src="images/collectFirst.svg" alt="collectFirst" />
          </figure>
        </article>
        <article id="combinations">
          <h2>combinations</h2>
          <p>Itera sobre combinaciones. </p>
          <p><code>combinations(n: Int): Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/combinations.svg" alt="combinations" />
          </figure>
        </article>
        <article id="contains">
          <h2>contains</h2>
          <p>Comprueba si esta colección contiene un valor dado en forma de elemento. </p>
          <p><code>contains[A1 &gt;: A](elem: A1): Boolean</code></p>
          <figure>
            <img src="images/contains.svg" alt="contains" />
          </figure>
        </article>
        <article id="containsSlice">
          <h2>containsSlice</h2>
          <p>Comprueba si esta colección contiene una secuencia dada en forma de subcolección. </p>
          <p><code>containsSlice[B](that: GenSeq[B]): Boolean</code></p>
          <figure>
            <img src="images/containsSlice.svg" alt="containsSlice" />
          </figure>
        </article>
        <article id="count">
          <h2>count</h2>
          <p>Cuenta el número de elementos en la colección que satisfacen un predicado. </p>
          <p><code>count(p: (A) ⇒ Boolean): Int</code></p>
          <figure>
            <img src="images/count.svg" alt="count" />
          </figure>
        </article>
        <article id="diff">
          <h2>diff</h2>
          <p>Calcula la diferencia multiconjunto entre esta colección y otra. </p>
          <p><code>diff(that: Seq[A]): Collection[A]</code></p>
          <figure>
            <img src="images/diff.svg" alt="diff" />
          </figure>
        </article>
        <article id="distinct">
          <h2>distinct</h2>
          <p>Construye una nueva colección a partir de esta sin ningún elemento duplicado. </p>
          <p><code>distinct: Collection[A]</code></p>
          <figure>
            <img src="images/distinct.svg" alt="distinct" />
          </figure>
        </article>
        <article id="drop">
          <h2>drop</h2>
          <p>Selecciona todos los elementos excepto los <var>n</var> primeros. </p>
          <p><code>drop(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/drop.svg" alt="drop" />
          </figure>
        </article>
        <article id="dropRight">
          <h2>dropRight</h2>
          <p>Selecciona todos los elementos excepto los <var>n</var> últimos. </p>
          <p><code>dropRight(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/dropRight.svg" alt="dropRight" />
          </figure>
        </article>
        <article id="dropWhile">
          <h2>dropWhile</h2>
          <p>Descarta el mayor prefijo de elementos que satisfacen un predicado. </p>
          <p><code>dropWhile(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/dropWhile.svg" alt="dropWhile" />
          </figure>
        </article>
        <article id="endsWith">
          <h2>endsWith</h2>
          <p>Comprueba si esta colección termina con una secuencia dada. </p>
          <p><code>endsWith[B](that: GenSeq[B]): Boolean</code></p>
          <figure>
            <img src="images/endsWith.svg" alt="endsWith" />
          </figure>
        </article>
        <article id="exists">
          <h2>exists</h2>
          <p>Comprueba si un predicado es válido para al menos un elemento de esta colección. </p>
          <p><code>exists(p: (A) ⇒ Boolean): Boolean</code></p>
          <figure>
            <img src="images/exists.svg" alt="exists" />
          </figure>
        </article>
        <article id="filter">
          <h2>filter</h2>
          <p>Selecciona todos los elementos de la colección que satisfacen un predicado. </p>
          <p><code>filter(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/filter.svg" alt="filter" />
          </figure>
        </article>
        <article id="filterNot">
          <h2>filterNot</h2>
          <p>Selecciona todos los elementos de la colección que no satisfacen un predicado. </p>
          <p><code>filterNot(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/filterNot.svg" alt="filterNot" />
          </figure>
        </article>
        <article id="find">
          <h2>find</h2>
          <p>Encuentra el primer elemento de la colección que satisface un predicado, si es que existe. </p>
          <p><code>find(p: (A) ⇒ Boolean): Option[A]</code></p>
          <figure>
            <img src="images/find.svg" alt="find" />
          </figure>
        </article>
        <article id="flatMap">
          <h2>flatMap</h2>
          <p>Construye una nueva colección tras aplicar una función a todos los elementos de esta colección. La función devuelve una colección de elementos. </p>
          <p><code>flatMap[B](f: (A) ⇒ Collection[B]): Collection[B]</code></p>
          <figure>
            <img src="images/flatMap.svg" alt="flatMap" />
          </figure>
        </article>
        <article id="flatten">
          <h2>flatten</h2>
          <p>Convierte esta colección de colecciones en una colección compuesta por los elementos de las colecciones internas. </p>
          <p><code>flatten[B]: Collection[B]</code></p>
          <figure>
            <img src="images/flatten.svg" alt="flatten" />
          </figure>
        </article>
        <article id="fold">
          <h2>fold</h2>
          <p>Pliega los elementos de esta colección utilizando un operador binario asociativo. </p>
          <p><code>fold[A1 &gt;: A](z: A1)(op: (A1, A1) ⇒ A1): A1</code></p>
          <figure>
            <img src="images/fold.svg" alt="fold" />
          </figure>
        </article>
        <article id="foldLeft">
          <h2>foldLeft</h2>
          <p>Aplica un operador binario a un valor inicial y a todos los elementos de la colección, yendo de izquierda a derecha. </p>
          <p><code>foldLeft[B](z: B)(op: (B, A) ⇒ B): B</code></p>
          <figure>
            <img src="images/foldLeft.svg" alt="foldLeft" />
          </figure>
        </article>
        <article id="foldRight">
          <h2>foldRight</h2>
          <p>Aplica un operador binario a un valor inicial y a todos los elementos de la colección, yendo de derecha a izquierda. </p>
          <p><code>foldRight[B](z: B)(op: (A, B) ⇒ B): B</code></p>
          <figure>
            <img src="images/foldRight.svg" alt="foldRight" />
          </figure>
        </article>
        <article id="forall">
          <h2>forall</h2>
          <p>Comprueba si un predicado es válido para todos los elementos de esta colección. </p>
          <p><code>forall(p: (A) ⇒ Boolean): Boolean</code></p>
          <figure>
            <img src="images/forall.svg" alt="forall" />
          </figure>
        </article>
        <article id="foreach">
          <h2>foreach</h2>
          <p>Aplica una función <var>f</var> a todos los elementos de esta colección. </p>
          <p><code>foreach(f: (A) ⇒ Unit): Unit</code></p>
          <figure>
            <img src="images/foreach.svg" alt="foreach" />
          </figure>
        </article>
        <article id="groupBy">
          <h2>groupBy</h2>
          <p>Parte esta colección en un mapa de colecciones de acuerdo a una función discriminadora. </p>
          <p><code>groupBy[K](f: (A) ⇒ K): Map[K, Collection[A]]</code></p>
          <figure>
            <img src="images/groupBy.svg" alt="groupBy" />
          </figure>
        </article>
        <article id="grouped">
          <h2>grouped</h2>
          <p>Parte los elementos en colecciones iterables de tamaño fijo. </p>
          <p><code>grouped(size: Int): Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/grouped.svg" alt="grouped" />
          </figure>
        </article>
        <article id="head">
          <h2>head</h2>
          <p>Selecciona el primer elemento de esta colección. </p>
          <p><code>head: A</code></p>
          <figure>
            <img src="images/head.svg" alt="head" />
          </figure>
        </article>
        <article id="headOption">
          <h2>headOption</h2>
          <p>Opcionalmente selecciona el primer elemento de esta colección. </p>
          <p><code>headOption: Option[A]</code></p>
          <figure>
            <img src="images/headOption.svg" alt="headOption" />
          </figure>
        </article>
        <article id="indexOf">
          <h2>indexOf</h2>
          <p>Encuentra el índice de la primera ocurrencia de algún valor en esta colección empezando por un índice inicial. </p>
          <p><code>indexOf(elem: A, from: Int): Int</code></p>
          <figure>
            <img src="images/indexOf.svg" alt="indexOf" />
          </figure>
        </article>
        <article id="indexOfSlice">
          <h2>indexOfSlice</h2>
          <p>Encuentra el primer índice empezando por uno inicial donde esta colección contiene una secuencia dada como subcolección. </p>
          <p><code>indexOfSlice[B &gt;: A](that: GenSeq[B], from: Int): Int</code></p>
          <figure>
            <img src="images/indexOfSlice.svg" alt="indexOfSlice" />
          </figure>
        </article>
        <article id="indexWhere">
          <h2>indexWhere</h2>
          <p>Encuentra el índice el primer elemento que satisface un predicado empezando por un índice inicial. </p>
          <p><code>indexWhere(p: (A) ⇒ Boolean, from: Int): Int</code></p>
          <figure>
            <img src="images/indexWhere.svg" alt="indexWhere" />
          </figure>
        </article>
        <article id="indices">
          <h2>indices</h2>
          <p>Produce un rango con todos los índices de esta colección. </p>
          <p><code>indices: Range</code></p>
          <figure>
            <img src="images/indices.svg" alt="indices" />
          </figure>
        </article>
        <article id="init">
          <h2>init</h2>
          <p>Selecciona todos los elementos excepto el último. </p>
          <p><code>init: Collection[A]</code></p>
          <figure>
            <img src="images/init.svg" alt="init" />
          </figure>
        </article>
        <article id="inits">
          <h2>inits</h2>
          <p>Itera sobre los <code>inits</code> de esta colección. </p>
          <p><code>inits: Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/inits.svg" alt="inits" />
          </figure>
        </article>
        <article id="intersect">
          <h2>intersect</h2>
          <p>Computa la intersección multiconjunto entre esta colección y otra secuencia. </p>
          <p><code>intersect(that: Seq[A]): Collection[A]</code></p>
          <figure>
            <img src="images/intersect.svg" alt="intersect" />
          </figure>
        </article>
        <article id="isEmpty">
          <h2>isEmpty</h2>
          <p>Comprueba si esta colección está vacía. </p>
          <p><code>isEmpty: Boolean</code></p>
          <figure>
            <img src="images/isEmpty.svg" alt="isEmpty" />
          </figure>
        </article>
        <article id="last">
          <h2>last</h2>
          <p>Selecciona el último elemento. </p>
          <p><code>last: A</code></p>
          <figure>
            <img src="images/last.svg" alt="last" />
          </figure>
        </article>
        <article id="lastIndexOf">
          <h2>lastIndexOf</h2>
          <p>Encuentra el índice de la última ocurrencia de algún valor en esta colección antes de un índice en particular. </p>
          <p><code>lastIndexOf(elem: A, end: Int): Int</code></p>
          <figure>
            <img src="images/lastIndexOf.svg" alt="lastIndexOf" />
          </figure>
        </article>
        <article id="lastIndexOfSlice">
          <h2>lastIndexOfSlice</h2>
          <p>Encuentra el último índice antes de uno en particular donde esta colección contiene una secuencia dada como subcolección. </p>
          <p><code>lastIndexOfSlice[B &gt;: A](that: GenSeq[B], end: Int): Int</code></p>
          <figure>
            <img src="images/lastIndexOfSlice.svg" alt="lastIndexOfSlice" />
          </figure>
        </article>
        <article id="lastIndexWhere">
          <h2>lastIndexWhere</h2>
          <p>Encuentra el índice del último elemento que satisface algún predicado antes de un índice en particular. </p>
          <p><code>lastIndexWhere(p: (A) ⇒ Boolean, end: Int): Int</code></p>
          <figure>
            <img src="images/lastIndexWhere.svg" alt="lastIndexWhere" />
          </figure>
        </article>
        <article id="lastOption">
          <h2>lastOption</h2>
          <p>Opcionalmente selecciona el último elemento. </p>
          <p><code>lastOption: Option[A]</code></p>
          <figure>
            <img src="images/lastOption.svg" alt="lastOption" />
          </figure>
        </article>
        <article id="length">
          <h2>length</h2>
          <p>La longitud de la colección. </p>
          <p><code>length: Int</code></p>
          <figure>
            <img src="images/length.svg" alt="length" />
          </figure>
        </article>
        <article id="map">
          <h2>map</h2>
          <p>Construye una nueva colección aplicando una función a todos los elementos de esta colección. </p>
          <p><code>map[B](f: (A) ⇒ B): Collection[B]</code></p>
          <figure>
            <img src="images/map.svg" alt="map" />
          </figure>
        </article>
        <article id="mapConserve">
          <h2>mapConserve</h2>
          <p>Construye una nueva colección aplicando una función a todos los elementos de esta colección. Igual que <code>xs map f</code> pero devuelve <var>xs</var> intacto si la función <var>f</var> mapea todos los elementos a sí mismos (determinado por <var>eq</var>) </p>
          <p><code>mapConserve(f: (A) ⇒ A): Collection[A]</code></p>
          <figure>
            <img src="images/mapConserve.svg" alt="mapConserve" />
          </figure>
        </article>
        <article id="max">
          <h2>max</h2>
          <p>Encuentra el mayor elemento. </p>
          <p><code>max: A</code></p>
          <figure>
            <img src="images/max.svg" alt="max" />
          </figure>
        </article>
        <article id="maxBy">
          <h2>maxBy</h2>
          <p>Encuentra el primer elemento que arroja el mayor valor medido por la función <var>f</var>. </p>
          <p><code>maxBy[B](f: (A) ⇒ B): A</code></p>
          <figure>
            <img src="images/maxBy.svg" alt="maxBy" />
          </figure>
        </article>
        <article id="min">
          <h2>min</h2>
          <p>Encuentra el menor elemento. </p>
          <p><code>min: A</code></p>
          <figure>
            <img src="images/min.svg" alt="min" />
          </figure>
        </article>
        <article id="minBy">
          <h2>minBy</h2>
          <p>Encuentra el primer elemento que arroja el menor valor medido por la función <var>f</var>. </p>
          <p><code>minBy[B](f: (A) ⇒ B): A</code></p>
          <figure>
            <img src="images/minBy.svg" alt="minBy" />
          </figure>
        </article>
        <article id="mkString">
          <h2>mkString</h2>
          <p>Muestra todos los elementos de esta colección como una cadena. </p>
          <p><code>mkString(start: String, sep: String, end: String): String</code></p>
          <figure>
            <img src="images/mkString.svg" alt="mkString" />
          </figure>
        </article>
        <article id="nonEmpty">
          <h2>nonEmpty</h2>
          <p>Comprueba si esta colección es no vacía. </p>
          <p><code>nonEmpty: Boolean</code></p>
          <figure>
            <img src="images/nonEmpty.svg" alt="nonEmpty" />
          </figure>
        </article>
        <article id="padTo">
          <h2>padTo</h2>
          <p>Una copia de esta colección anexando un mismo valor hasta alcanzar una longitud dada. </p>
          <p><code>padTo(len: Int, elem: A): Collection[A]</code></p>
          <figure>
            <img src="images/padTo.svg" alt="padTo" />
          </figure>
        </article>
        <article id="partition">
          <h2>partition</h2>
          <p>Parte esta colección en dos colecciones de acuerdo a un predicado. </p>
          <p><code>partition(p: (A) ⇒ Boolean): (Collection[A], Collection[A])</code></p>
          <figure>
            <img src="images/partition.svg" alt="partition" />
          </figure>
        </article>
        <article id="patch">
          <h2>patch</h2>
          <p>Produce una nueva colección donde una subcolección de elementos es reemplazada por otra secuencia. </p>
          <p><code>patch(from: Int, that: GenSeq[A], replaced: Int): Collection[A]</code></p>
          <figure>
            <img src="images/patch.svg" alt="patch" />
          </figure>
        </article>
        <article id="permutations">
          <h2>permutations</h2>
          <p>Itera sobre distintas permutaciones. </p>
          <p><code>permutations: Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/permutations.svg" alt="permutations" />
          </figure>
        </article>
        <article id="prefixLength">
          <h2>prefixLength</h2>
          <p>Devuelve la longitud del mayor prefijo cuyos elementos satisfacen algún predicado. </p>
          <p><code>prefixLength(p: (A) ⇒ Boolean): Int</code></p>
          <figure>
            <img src="images/prefixLength.svg" alt="prefixLength" />
          </figure>
        </article>
        <article id="product">
          <h2>product</h2>
          <p>Multiplica los elementos de esta colección. </p>
          <p><code>product: A</code></p>
          <figure>
            <img src="images/product.svg" alt="product" />
          </figure>
        </article>
        <article id="reduce">
          <h2>reduce</h2>
          <p>Reduce los elementos de esta colección utilizando un operador binario asociativo. </p>
          <p><code>reduce[A1 &gt;: A](op: (A1, A1) ⇒ A1): A1</code></p>
          <figure>
            <img src="images/reduce.svg" alt="reduce" />
          </figure>
        </article>
        <article id="reduceLeft">
          <h2>reduceLeft</h2>
          <p>Aplica un operador binario a todos los elementos de esta colección, yendo de izquierda a derecha. </p>
          <p><code>reduceLeft[B &gt;: A](op: (B, A) ⇒ B): B</code></p>
          <figure>
            <img src="images/reduceLeft.svg" alt="reduceLeft" />
          </figure>
        </article>
        <article id="reduceLeftOption">
          <h2>reduceLeftOption</h2>
          <p>Opcionalmente aplica un operador binario a todos los elementos de esta colección, yendo de izquierda a derecha. </p>
          <p><code>reduceLeftOption[B &gt;: A](op: (B, A) ⇒ B): Option[B]</code></p>
          <figure>
            <img src="images/reduceLeftOption.svg" alt="reduceLeftOption" />
          </figure>
        </article>
        <article id="reduceOption">
          <h2>reduceOption</h2>
          <p>Reduce los elementos de esta colección, si lo hubiese, utilizando un operador binario asociativo. </p>
          <p><code>reduceOption[A1 &gt;: A](op: (A1, A1) ⇒ A1): Option[A1]</code></p>
          <figure>
            <img src="images/reduceOption.svg" alt="reduceOption" />
          </figure>
        </article>
        <article id="reduceRight">
          <h2>reduceRight</h2>
          <p>Aplica un operador binario a todos los elementos de esta colección, yendo de derecha a izquierda. </p>
          <p><code>reduceRight[B &gt;: A](op: (A, B) ⇒ B): B</code></p>
          <figure>
            <img src="images/reduceRight.svg" alt="reduceRight" />
          </figure>
        </article>
        <article id="reduceRightOption">
          <h2>reduceRightOption</h2>
          <p>Opcionalmente aplica un operador binario a todos los elementos de esta colección, yendo de derecha a izquierda. </p>
          <p><code>reduceRightOption[B &gt;: A](op: (A, B) ⇒ B): Option[B]</code></p>
          <figure>
            <img src="images/reduceRightOption.svg" alt="reduceRightOption" />
          </figure>
        </article>
        <article id="reverse">
          <h2>reverse</h2>
          <p>Devuelve una nueva colección con los elementos en orden inverso. </p>
          <p><code>reverse: Collection[A]</code></p>
          <figure>
            <img src="images/reverse.svg" alt="reverse" />
          </figure>
        </article>
        <article id="reverseMap">
          <h2>reverseMap</h2>
          <p>Construye una nueva colección aplicando una función a todos los elementos de esta colección y recolectando los resultados en orden inverso. </p>
          <p><code>reverseMap(f: (A) ⇒ B): Collection[A]</code></p>
          <figure>
            <img src="images/reverseMap.svg" alt="reverseMap" />
          </figure>
        </article>
        <article id="sameElements">
          <h2>sameElements</h2>
          <p>Comprueba si otra colección contiene los mismos elementos en el mismo orden que esta. </p>
          <p><code>sameElements(that: GenIterable[A]): Boolean</code></p>
          <figure>
            <img src="images/sameElements.svg" alt="sameElements" />
          </figure>
        </article>
        <article id="scan">
          <h2>scan</h2>
          <p>Computa un scan prefijado de los elementos de la colección. </p>
          <p><code>scan[B &gt;: A](z: B)(op: (B, B) ⇒ B)</code></p>
          <figure>
            <img src="images/scan.svg" alt="scan" />
          </figure>
        </article>
        <article id="scanLeft">
          <h2>scanLeft</h2>
          <p>Produce una colección que contiene los resultados parciales de aplicar el operador, yendo de izquierda a derecha. </p>
          <p><code>scanLeft[B](z: B)(op: (B, A) ⇒ B)</code></p>
          <figure>
            <img src="images/scanLeft.svg" alt="scanLeft" />
          </figure>
        </article>
        <article id="scanRight">
          <h2>scanRight</h2>
          <p>Produce una colección que contiene los resultados parciales de aplicar el operador, yendo de derecha a izquierda. </p>
          <p><code>scanRight[B](z: B)(op: (A, B) ⇒ B)</code></p>
          <figure>
            <img src="images/scanRight.svg" alt="scanRight" />
          </figure>
        </article>
        <article id="segmentLength">
          <h2>segmentLength</h2>
          <p>Computa la longitud del mayor segmento cuyos elementos satisfacen un predicado. </p>
          <p><code>segmentLength(p: (A) ⇒ Boolean, from: Int): Int</code></p>
          <figure>
            <img src="images/segmentLength.svg" alt="segmentLength" />
          </figure>
        </article>
        <article id="size">
          <h2>size</h2>
          <p>El tamaño de esta colección. </p>
          <p><code>size: Int</code></p>
          <figure>
            <img src="images/size.svg" alt="size" />
          </figure>
        </article>
        <article id="slice">
          <h2>slice</h2>
          <p>   </p>
          <p><code>slice(from: Int, until: Int): Collection[A]</code></p>
          <figure>
            <img src="images/slice.svg" alt="slice" />
          </figure>
        </article>
        <article id="sliding">
          <h2>sliding</h2>
          <p>Agrupa elementos en bloques de tamaño fijo pasando una "ventana deslizante" sobre ellos. </p>
          <p><code>sliding(size: Int, step: Int): Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/sliding.svg" alt="sliding" />
          </figure>
        </article>
        <article id="sortBy">
          <h2>sortBy</h2>
          <p>Ordena esta colección de acuerdo al Ordering resultado de transformar un Ordering dado implícitamente con una función de transformación. </p>
          <p><code>sortBy[B](f: (A) ⇒ B)(implicit ord: math.Ordering[B]): Collection[A]</code></p>
          <figure>
            <img src="images/sortBy.svg" alt="sortBy" />
          </figure>
        </article>
        <article id="sortWith">
          <h2>sortWith</h2>
          <p>Ordena esta colección de acuerdo a una función de comparación. </p>
          <p><code>sortWith(lt: (A, A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/sortWith.svg" alt="sortWith" />
          </figure>
        </article>
        <article id="sorted">
          <h2>sorted</h2>
          <p>Ordena esta colección de acuerdo a un Ordering. </p>
          <p><code>sorted[B &gt;: A]</code></p>
          <figure>
            <img src="images/sorted.svg" alt="sorted" />
          </figure>
        </article>
        <article id="span">
          <h2>span</h2>
          <p>Parte esta colección en un par prefijo/sufijo de acuerdo a un predicado. </p>
          <p><code>span(p: (A) ⇒ Boolean): (Collection[A], Collection[A])</code></p>
          <figure>
            <img src="images/span.svg" alt="span" />
          </figure>
        </article>
        <article id="splitAt">
          <h2>splitAt</h2>
          <p>Parte esta colección en dos en una posición dada. </p>
          <p><code>splitAt(n: Int): (Collection[A], Collection[A])</code></p>
          <figure>
            <img src="images/splitAt.svg" alt="splitAt" />
          </figure>
        </article>
        <article id="startsWith">
          <h2>startsWith</h2>
          <p>Comprueba si esta colección contiene la secuencia dada en un índice en particular. </p>
          <p><code>startsWith[B](that: GenSeq[B], offset: Int): Boolean</code></p>
          <figure>
            <img src="images/startsWith.svg" alt="startsWith" />
          </figure>
        </article>
        <article id="sum">
          <h2>sum</h2>
          <p>Suma los elementos de esta colección. </p>
          <p><code>sum: A</code></p>
          <figure>
            <img src="images/sum.svg" alt="sum" />
          </figure>
        </article>
        <article id="tail">
          <h2>tail</h2>
          <p>Selecciona todos los elementos excepto el primero. </p>
          <p><code>tail: Collection[A]</code></p>
          <figure>
            <img src="images/tail.svg" alt="tail" />
          </figure>
        </article>
        <article id="tails">
          <h2>tails</h2>
          <p>Itera sobre las colas de esta colección. </p>
          <p><code>tails: Iterator[Collection[A]]</code></p>
          <figure>
            <img src="images/tails.svg" alt="tails" />
          </figure>
        </article>
        <article id="take">
          <h2>take</h2>
          <p>Selecciona los primeros <var>n</var> elementos. </p>
          <p><code>take(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/take.svg" alt="take" />
          </figure>
        </article>
        <article id="takeRight">
          <h2>takeRight</h2>
          <p>Selecciona los últimos <var>n</var> elementos. </p>
          <p><code>takeRight(n: Int): Collection[A]</code></p>
          <figure>
            <img src="images/takeRight.svg" alt="takeRight" />
          </figure>
        </article>
        <article id="takeWhile">
          <h2>takeWhile</h2>
          <p>Toma el mayor prefijo de elementos que satisfacen un predicado. </p>
          <p><code>takeWhile(p: (A) ⇒ Boolean): Collection[A]</code></p>
          <figure>
            <img src="images/takeWhile.svg" alt="takeWhile" />
          </figure>
        </article>
        <article id="union">
          <h2>union</h2>
          <p>Produce una nueva colección que contiene todos los elementos de esta y los de otra secuencia. </p>
          <p><code>union(that: Seq[A]): Collection[A]</code></p>
          <figure>
            <img src="images/union.svg" alt="union" />
          </figure>
        </article>
        <article id="unzip">
          <h2>unzip</h2>
          <p>Convierte esta colección de pares en dos colecciones, una compuesta por el primer miembro y otra por el segundo. </p>
          <p><code>unzip[A1, A2](implicit asPair: (A) ⇒ (A1, A2)): (Collection[A1], Collection[A2])</code></p>
          <figure>
            <img src="images/unzip.svg" alt="unzip" />
          </figure>
        </article>
        <article id="unzip3">
          <h2>unzip3</h2>
          <p>Convierte esta colección de ternas en tres colecciones del primer, segundo y tercer elemento de cada terna. </p>
          <p><code>unzip3[A1, A2, A3](implicit asTriple: (A) ⇒ (A1, A2, A3)): (Collection[A1], Collection[A2], Collection[A3])</code></p>
          <figure>
            <img src="images/unzip3.svg" alt="unzip3" />
          </figure>
        </article>
        <article id="updated">
          <h2>updated</h2>
          <p>Una copia de esta colección con un único elemento reemplazado. </p>
          <p><code>updated(index: Int, elem: A): Collection[A]</code></p>
          <figure>
            <img src="images/updated.svg" alt="updated" />
          </figure>
        </article>
        <article id="zip">
          <h2>zip</h2>
          <p>Devuelve una colección formada por los elementos de dos colecciones distintas combinados en parejas. </p>
          <p><code>zip[B](that: GenIterable[B]): Collection[A, B]</code></p>
          <figure>
            <img src="images/zip.svg" alt="zip" />
          </figure>
        </article>
        <article id="zipAll">
          <h2>zipAll</h2>
          <p>Devuelve una colección formada por los elementos de dos colecciones distintas combinados en parejas. Si una de las colecciones es menor que la otra, se usan elementos comodín en la más corta hasta alcanzar la longitud de la más larga. </p>
          <p><code>zipAll[B](that: Iterable[B], thisElem: A, thatElem: B): Collection[(A, B)]</code></p>
          <figure>
            <img src="images/zipAll.svg" alt="zipAll" />
          </figure>
        </article>
        <article id="zipWithIndex">
          <h2>zipWithIndex</h2>
          <p>Combina cada elemento de esta colección con su índice. </p>
          <p><code>zipWithIndex: Collection[A, Int]</code></p>
          <figure>
            <img src="images/zipWithIndex.svg" alt="zipWithIndex" />
          </figure>
        </article>
    </sectio>
  </div>
</body>
</html>
